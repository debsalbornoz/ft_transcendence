# Key Architectural Decisions & Justifications
**Ft_Transcendence - Lead Generation Platform**

---

## ðŸŽ¯ Overview

This document captures the major architectural and design decisions made for the lead generation platform, including **why** each choice was made, **alternatives considered**, and **trade-offs accepted**.

---

## ðŸ” Decision #1: Multi-Tenant Architecture with Organization Isolation

### The Decision
**Implement a shared-database, row-level tenant isolation model** where all organizations' data is in a single PostgreSQL database, but each organization can only see their own data through application-enforced filters.

### Why This Approach
1. **Simplicity:** Single database = single backup, single monitoring, easier deployment
2. **Cost efficiency:** Shared infrastructure for multiple customers
3. **Faster feature rollout:** New features available to all orgs simultaneously
4. **Shared data benefits:** Can offer cross-org analytics in future (anonymized)

### Alternatives Considered

| Approach | Pros | Cons | Why Not |
|----------|------|------|---------|
| **Shared DB + Row-level Security** (Chosen) | Simple, cost-effective | Complex isolation logic | â† BEST FOR 42 TIMELINE |
| Separate database per org | Perfect isolation, easy to debug | 2-3x infrastructure cost, ops nightmare | Too expensive/complex |
| Shared DB + Row-Level Security (PostgreSQL) | Native DB-level isolation | Complex setup, less control | Overkill for MVP |
| Multi-cloud/multi-region | Max availability | Extremely complex | Beyond scope |

### Trade-offs Accepted
- âœ… **Accept:** Application-level isolation requires discipline (all queries must filter by org_id)
- âœ… **Accept:** Single point of failure (mitigated with backups)
- âœ… **Gain:** Operational simplicity and cost efficiency

### Implementation Pattern
```typescript
// Every query MUST include organization_id filter
const userOrgs = await prisma.organization.findMany({
  where: {
    id: organizationId,  // â† REQUIRED
    deletedAt: null      // â† SOFT DELETE
  },
});

// Middleware enforces this at API level
```

### Risk Mitigation
- [ ] Create middleware that auto-appends `organization_id` to all queries
- [ ] Use TypeScript compile-time checks where possible
- [ ] Add runtime asserts in sensitive queries
- [ ] Regular audit of queries in codebase
- [ ] Test data isolation in integration tests

---

## ðŸ›¡ï¸ Decision #2: RBAC (Role-Based Access Control) with Explicit Permissions

### The Decision
**Implement Role-based permissions where users have a role (admin, consultant, viewer) within each organization, and roles have explicit permissions (campaign.create, lead.export, etc.).**

### Why This Approach
1. **Flexible:** Easy to add new roles without code changes
2. **Scalable:** Permissions can be fine-grained as needed
3. **Auditable:** Clear record of who had what access
4. **Defensive:** Fails safely (deny by default)

### Alternatives Considered

| Approach | Pros | Cons | Why Not |
|----------|------|------|---------|
| **Explicit Role-Permission Model** (Chosen) | Flexible, scalable, auditable | More tables/complexity | â† BEST FOR GROWTH |
| Simple role enum (ADMIN, USER, VIEWER) | Simple, fast | Inflexible, hard to add granular controls | Too rigid |
| Attribute-based access (ABAC) | Extremely flexible | Complex to implement/maintain | Overkill for MVP |
| No roles (treat all users equally) | Simplest | Not a viable SaaS model | Not acceptable |

### Trade-offs Accepted
- âœ… **Accept:** More database tables (Role, Permission, Membership)
- âœ… **Gain:** True flexibility and auditability

### Implementation Pattern
```typescript
// Check role + permission before allowing action
const canCreateCampaign = await prisma.membership.findFirst({
  where: {
    userId: currentUser.id,
    organizationId: orgId,
  },
  include: {
    role: {
      include: {
        permissions: {
          where: { key: "campaign.create" }
        }
      }
    }
  }
});

if (!canCreateCampaign?.role.permissions.length) {
  throw new ForbiddenError("Insufficient permissions");
}
```

### Predefined Roles
```
ADMIN:
  - campaign.create, campaign.update, campaign.delete
  - contact.import, contact.validate, contact.export
  - lead.view, lead.export, lead.delete
  - user.invite, user.remove, user.changeRole
  - organization.settings, organization.billing

CONSULTANT:
  - campaign.create, campaign.update (own campaigns)
  - contact.import
  - lead.view, lead.export
  - report.view

VIEWER:
  - campaign.view
  - lead.view
  - report.view (read-only)
```

---

## ðŸ“Š Decision #3: Soft Delete Pattern Instead of Hard Delete

### The Decision
**Use soft delete (mark deleted_at timestamp) for most entities instead of permanently removing data.**

### Why This Approach
1. **GDPR compliance:** Easy to anonymize instead of delete
2. **Audit trail:** Can see historical data and who deleted what
3. **Recovery:** Can restore data if user changes mind
4. **Analytics:** Historical analysis not affected

### Alternatives Considered

| Approach | Pros | Cons | Why Not |
|----------|------|------|---------|
| **Soft Delete** (Chosen) | Auditable, reversible, GDPR-friendly | More query complexity | â† REQUIRED FOR COMPLIANCE |
| Hard Delete | Simple, cleaner data | No audit trail, can't recover | Violates GDPR |
| Archive to separate table | Similar to soft delete | Complex migrations | Unnecessary complexity |

### Trade-offs Accepted
- âœ… **Accept:** Every query must include `WHERE deleted_at IS NULL`
- âœ… **Gain:** Full audit trail and GDPR compliance

### Implementation Pattern
```typescript
// Query excludes soft-deleted records by default
const activeContacts = await prisma.contact.findMany({
  where: {
    organizationId: orgId,
    deletedAt: null,  // â† REQUIRED
  },
});

// Soft delete operation
await prisma.contact.update({
  where: { id: contactId },
  data: { deletedAt: new Date() }
});

// Hard delete (after retention period, e.g., 2 years)
await prisma.contact.deleteMany({
  where: {
    organizationId: orgId,
    deletedAt: { lt: new Date(Date.now() - 2 * 365 * 24 * 60 * 60 * 1000) }
  }
});
```

### Soft Delete Entities
- Organizations, Users, Memberships
- ContactLists, Contacts
- Campaigns, EmailTemplates, Forms
- Leads, FormResponses
- AuditLogs, GDPRRequests

### Hard Delete (Append-Only, Never Soft Deleted)
- Events (analytics integrity)
- AuditLogs (compliance record)
- ValidationLogs (audit trail)

---

## ðŸ“ˆ Decision #4: Event Aggregation vs On-the-Fly Calculations

### The Decision
**Pre-compute daily metrics in an EventAggregation table rather than calculating dashboard stats on-the-fly from raw Events.**

### Why This Approach
1. **Performance:** Dashboard queries run in milliseconds, not seconds
2. **Scalability:** Events table can grow to millions of rows without slowing dashboards
3. **Consistency:** Daily aggregations are locked for historical accuracy
4. **Simplicity:** Dashboard queries become simple table lookups

### Alternatives Considered

| Approach | Pros | Cons | Why Not |
|----------|------|------|---------|
| **Pre-aggregated Table** (Chosen) | Fast, scalable, consistent | 24h delay, extra storage | â† ESSENTIAL FOR SPEED |
| On-the-fly aggregation | Real-time, simple data model | Slow (complex queries), hard to cache | Unacceptable dashboard UX |
| Materialized Views | Nice SQL abstraction | Still requires refresh job | No real benefit over table |
| Time-series database | Optimized for high volume | Extra infrastructure/ops | Overkill for 42 project |

### Trade-offs Accepted
- âœ… **Accept:** Dashboard metrics are 1-24h delayed
- âœ… **Accept:** Extra storage for aggregation table
- âœ… **Gain:** Sub-100ms dashboard queries
- âœ… **Gain:** Can scale to 100M+ events

### Implementation Pattern
```typescript
// Nightly aggregation job (2 AM UTC)
async function aggregateDailyMetrics() {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);

  const rawMetrics = await prisma.event.groupBy({
    by: ['campaignId', 'eventType'],
    where: {
      timestamp: {
        gte: yesterday,
        lt: new Date(yesterday.getTime() + 24 * 60 * 60 * 1000)
      }
    },
    _count: true,
    _count: { distinct: 'contactId' }
  });

  // Upsert into aggregation table
  for (const metric of rawMetrics) {
    await prisma.eventAggregation.upsert({
      where: {
        campaignId_eventType_date: {
          campaignId: metric.campaignId,
          eventType: metric.eventType,
          date: yesterday
        }
      },
      create: {
        campaignId: metric.campaignId,
        eventType: metric.eventType,
        date: yesterday,
        count: metric._count,
        uniqueContacts: metric._count.distinct,
        isFinal: true  // locked after 24h
      },
      update: {
        count: metric._count,
        uniqueContacts: metric._count.distinct,
        isFinal: true,
        updatedAt: new Date()
      }
    });
  }
}

// Dashboard query (ultra-fast)
const metrics = await prisma.eventAggregation.findMany({
  where: {
    campaignId: campaignId,
    date: { gte: startDate, lte: endDate }
  },
  orderBy: { date: 'asc' }
});
// Result: 5-10ms query time âœ…
```

### Aggregation Window
- **Raw Events:** Kept for 2 years (queryable but slow)
- **Aggregations:** Kept indefinitely
- **Archive:** Events older than 2 years moved to cold storage

---

## ðŸ’¾ Decision #5: JSONB Columns for Flexible Schemas

### The Decision
**Use PostgreSQL JSONB columns for inherently flexible data (form responses, validation details, event payloads) rather than creating separate normalized tables.**

### Why This Approach
1. **Flexibility:** Forms have dynamic fields, can't predict schema upfront
2. **Performance:** JSONB is fast and indexable in PostgreSQL
3. **Simplicity:** Fewer tables and migrations
4. **Reality:** This is how modern systems handle flexible data

### Alternatives Considered

| Approach | Pros | Cons | Why Not |
|----------|------|------|---------|
| **JSONB Columns** (Chosen) | Flexible, fast, simple | Harder to aggregate | â† BEST FOR SEMI-STRUCTURED DATA |
| Fully normalized (separate tables) | Highly indexed, queryable | Complex schema, slow writes | Too rigid for forms |
| EAV model (entity-attribute-value) | Traditional approach | Very slow queries | Legacy pattern |
| No schema at all (MongoDB) | Ultimate flexibility | No ACID guarantees | Wrong tool |

### Trade-offs Accepted
- âœ… **Accept:** Some queries are harder (but use aggregation pattern)
- âœ… **Gain:** Can add form fields without schema changes

### JSONB Usage in Schema

| Table | Column | Purpose | Example |
|-------|--------|---------|---------|
| FormResponse | response_data | Form submission values | { "quantity_of_lives": 100, "age_range": "30-40" } |
| Event | event_data | Event details | { "url_clicked": "https://...", "link_text": "Learn More" } |
| Contact | validation_details | Email validation result | { "syntax_ok": true, "domain_exists": true, "risk_score": 0.1 } |
| ValidationRule | rule_config | Validation parameters | { "domains_to_check": ["example.com"], "risk_threshold": 0.5 } |
| AuditLog | changes | What changed | { "name": { "old": "Old Name", "new": "New Name" } } |

### Querying JSONB
```typescript
// Filter by JSONB field value
const responsesWithHighQuantity = await prisma.formResponse.findMany({
  where: {
    responseData: {
      path: ['quantity_of_lives'],
      gt: 500  // PostgreSQL JSONB operator
    }
  }
});

// Alternative: raw SQL for complex JSONB queries
const results = await prisma.$queryRaw`
  SELECT * FROM form_responses
  WHERE response_data->>'quantity_of_lives'::int > 500
`;

// Create GIN index for fast JSONB searches
// CREATE INDEX idx_form_response_data ON form_responses USING GIN (response_data);
```

---

## ðŸ”„ Decision #6: Email Sending Strategy (Simulation vs Real SMTP)

### The Decision
**Simulate email sending with a mock service that generates realistic events, rather than integrating real SMTP.**

### Why This Approach
1. **Practicality:** SMTP setup is complex (SPF, DKIM, reputation)
2. **Academic value:** Focus on architecture, not email ops
3. **Testing:** Deterministic simulation is better for reproducibility
4. **Speed:** No 3rd-party delays in development
5. **42 School:** Acceptable and defensible approach

### Simulation Architecture
```typescript
// Mock service config stored in database
model EmailSendSimulation {
  sendRate: 1.0,       // 100% of contacts get sent
  openRate: 0.20,      // 20% open the email
  clickRate: 0.10,     // 10% click a link
  bounceRate: 0.05,    // 5% bounce
  unsubscribeRate: 0.01 // 1% unsubscribe
  seed: 12345          // deterministic results
}

// Async job generates events
async function simulateCampaignSend(campaignId) {
  const config = await getSimulationConfig(campaignId);
  const contacts = await getContactsForCampaign(campaignId);

  for (const contact of contacts) {
    // Decide outcomes based on rates + seed
    if (randomWithSeed(config.seed, contact.id) < config.sendRate) {
      createEvent(campaignId, contact.id, 'SENT', { timestamp: now });
    }

    if (randomWithSeed(...) < config.openRate) {
      createEvent(campaignId, contact.id, 'OPEN', { timestamp: now + 2h });
    }

    if (randomWithSeed(...) < config.clickRate) {
      createEvent(campaignId, contact.id, 'CLICK', {
        url_clicked: landingPageUrl,
        timestamp: now + 4h
      });
    }

    // ... bounce, unsubscribe, form_submit events
  }

  // Trigger aggregation job
  await aggregateDailyMetrics();
}
```

### Why This is Defensible for 42 School
âœ… **The grading criteria care about:**
- âœ… Architecture correctness
- âœ… Database design
- âœ… Multi-tenant isolation
- âœ… RBAC implementation
- âœ… Analytics dashboard
- âœ… Event tracking

âŒ **They don't care about:**
- âŒ Real SMTP integration
- âŒ Email delivery rates
- âŒ ISP reputation

---

## ðŸŽ¯ Decision #7: Event Table Partitioning Strategy

### The Decision
**Design Event table to support partitioning by organization_id and/or date when table exceeds 1M rows.**

### Why This Approach
1. **Scalability:** Supports 100M+ events without slowing
2. **Archive:** Old events can move to cold storage easily
3. **Performance:** Queries can exclude irrelevant partitions
4. **Operations:** Easier to manage large tables

### Partitioning Scenarios

| Scenario | Partition By | When | Reason |
|----------|--------------|------|--------|
| **MVP (< 1M events)** | None | Months 1-3 | Too small to matter |
| **Scale (1-100M)** | organization_id | Months 3-6 | Multi-tenant workload isolation |
| **High Volume (> 100M)** | organization_id + date range | Months 6+ | Maximum performance |
| **Archival** | Move old partitions to S3 | 2+ year old data | Cold storage |

### Implementation Pattern
```sql
-- No partitioning needed for MVP, but schema supports it

-- When needed (later), partition by date:
CREATE TABLE events (
  id BIGINT PRIMARY KEY,
  organization_id INT,
  campaign_id INT,
  event_type VARCHAR,
  timestamp TIMESTAMP,
  ...
) PARTITION BY RANGE (timestamp);

CREATE TABLE events_2025_01 PARTITION OF events
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE events_2025_02 PARTITION OF events
  FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- Indexes per partition
CREATE INDEX idx_events_2025_01 ON events_2025_01
  (organization_id, campaign_id, event_type);
```

### Migration Path
1. **Phase 1:** Run with no partitioning (simpler)
2. **Phase 2:** Monitor Event table size
3. **Phase 3:** If > 100M rows, add date-based partitioning
4. **Phase 4:** Move old partitions to archive/cold storage

---

## ðŸš€ Decision #8: API Design Pattern (Next.js Route Handlers vs API Routes)

### The Decision
**Use Next.js Route Handlers (App Router) with TypeScript for type-safe, modern API design.**

### Why This Approach
1. **Modern:** App Router is the future of Next.js
2. **Type-safe:** Full TypeScript support end-to-end
3. **Integrated:** Middleware, logging, auth all built-in
4. **Performance:** Server Components can query DB directly

### API Organization
```
app/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ auth/[...nextauth]/
â”‚   â”œâ”€â”€ organizations/
â”‚   â”‚   â”œâ”€â”€ route.ts           # GET /api/organizations, POST
â”‚   â”‚   â””â”€â”€ [id]/
â”‚   â”‚       â”œâ”€â”€ route.ts       # GET, PUT, DELETE specific org
â”‚   â”‚       â””â”€â”€ members/
â”‚   â”‚           â””â”€â”€ route.ts   # GET, POST org members
â”‚   â”œâ”€â”€ campaigns/
â”‚   â”‚   â”œâ”€â”€ route.ts
â”‚   â”‚   â”œâ”€â”€ [id]/
â”‚   â”‚   â”‚   â”œâ”€â”€ route.ts
â”‚   â”‚   â”‚   â””â”€â”€ events/
â”‚   â”‚   â”‚       â””â”€â”€ route.ts   # GET campaign events
â”‚   â”œâ”€â”€ contacts/
â”‚   â”œâ”€â”€ leads/
â”‚   â””â”€â”€ ...
```

### Request/Response Pattern
```typescript
// app/api/campaigns/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getCurrentOrganization, requireAuth, canAccess } from '@/lib/auth';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Auth middleware
    const session = await requireAuth(request);
    const org = await getCurrentOrganization(session);

    // RBAC check
    await canAccess(session.user.id, org.id, 'campaign.view');

    // Fetch data with org isolation
    const campaign = await prisma.campaign.findUnique({
      where: {
        id: parseInt(params.id),
        organizationId: org.id  // â† ISOLATION
      }
    });

    if (!campaign) {
      return NextResponse.json(
        { error: 'Campaign not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(campaign);
  } catch (error) {
    // Error handling, logging, etc.
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  // Similar auth/rbac checks
  const body = await request.json();

  // Validation
  const result = campaignSchema.safeParse(body);
  if (!result.success) {
    return NextResponse.json(
      { error: result.error },
      { status: 400 }
    );
  }

  // Update with org isolation
  const updated = await prisma.campaign.update({
    where: {
      id: parseInt(params.id),
      organizationId: org.id  // â† ISOLATION
    },
    data: result.data
  });

  // Log to audit trail
  await logAuditEvent(session.user.id, org.id, 'campaign', 'update', updated);

  return NextResponse.json(updated);
}
```

---

## ðŸ” Decision #9: Form Field Flexibility (JSONB vs FormField Table)

### The Decision
**Store form structure as JSON in Forms.formFields AND create FormField table for indexed fast filtering.**

### Why Hybrid Approach
1. **Flexibility:** JSONB allows arbitrary field configs
2. **Queryability:** FormField table enables fast form_response filtering
3. **Best of both:** Flexibility + performance

### Implementation Pattern
```typescript
// Forms table (structure definition)
{
  formFields: [
    {
      fieldKey: "quantity_of_lives",
      fieldLabel: "Quantity of Lives",
      fieldType: "number",
      required: true,
      validation: { min: 1, max: 10000 }
    },
    {
      fieldKey: "age_range",
      fieldLabel: "Age Range",
      fieldType: "select",
      options: ["18-25", "26-35", "36-45", "46-55", "56+"]
    }
  ]
}

// FormField table (for indexed searching)
FormField {
  formId, fieldKey, fieldLabel, fieldType, isIndexed, position
}

// Queries
// Find all forms that ask for "quantity_of_lives"
const forms = await prisma.formField.findMany({
  where: { fieldKey: "quantity_of_lives" }
});

// Find responses where quantity > 500
const responses = await prisma.formResponse.findMany({
  where: {
    responseData: {
      path: ['quantity_of_lives'],
      gt: 500
    }
  }
});
```

---

## ðŸ“‹ Summary Table: Key Decisions

| Decision | Chosen Approach | Alternative | Why |
|----------|-----------------|-------------|-----|
| **Multi-tenancy** | Shared DB, row-level isolation | Separate DB per org | Cost/simplicity |
| **Access Control** | RBAC + explicit permissions | Simple role enum | Flexibility/scale |
| **Data Deletion** | Soft delete by default | Hard delete | GDPR compliance |
| **Dashboard Performance** | Pre-aggregated EventAggregation | On-the-fly calculations | Speed/scale |
| **Flexible Schemas** | JSONB columns | Fully normalized | Adaptability |
| **Email Sending** | Simulated with mock events | Real SMTP | Academic focus/practicality |
| **Partitioning** | Plan for future (none initially) | Partition from day 1 | YAGNI principle |
| **API Framework** | Next.js Route Handlers | Express/NestJS | Type safety/integration |
| **Form Fields** | Hybrid JSONB + FormField | Pure JSONB | Performance + flexibility |

---

## ðŸŽ“ Academic Justification for 42 Evaluation

### This design demonstrates:
âœ… **System Architecture:** Multi-tenant SaaS architecture
âœ… **Database Design:** Proper normalization + pragmatic JSONB usage
âœ… **Security:** RBAC, org isolation, audit trail
âœ… **Scalability:** Aggregation pattern for 100M+ events
âœ… **Compliance:** GDPR export/deletion, soft deletes
âœ… **Engineering Judgment:** Trade-offs explicitly documented

### Defensive arguments if questioned:
- Q: "Why soft delete?" â†’ A: "GDPR compliance + audit trail"
- Q: "Why not real SMTP?" â†’ A: "Focus on architecture, not ops; simulation is deterministic and testable"
- Q: "Why JSONB?" â†’ A: "Forms have dynamic fields; normalized schema would require migrations for every field"
- Q: "Why pre-aggregate?" â†’ A: "Dashboard must be fast even with 100M events; this is how production systems do it"

---

## ðŸ”„ Next Steps

1. **Validate** these decisions with DB architect
2. **Implement Phase 1** (Organization + RBAC)
3. **Build middleware** enforcing org_id filters
4. **Create comprehensive tests** for data isolation
5. **Document patterns** in codebase for team
6. **Monitor adoption** of patterns in code reviews

---

**Document Status:** Complete
**Last Updated:** January 2025
**Ready for Implementation:** âœ…
