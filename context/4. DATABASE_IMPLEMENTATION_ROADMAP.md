# Database Implementation Roadmap
**Ft_Transcendence - Lead Generation Platform**

---

## ðŸ“… 5-Phase Implementation Timeline

### **Phase 1: Foundation & Multi-Tenancy (Week 1)**
**Goal:** Build the tenant isolation layer and access control foundation

#### Tables to Create
1. `organizations` - Tenant root
2. `users` - Global user registry
3. `memberships` - User-Organization mapping
4. `roles` - RBAC role definitions
5. `permissions` - Permission catalog

#### Implementation Tasks
- [ ] Design schema for org isolation
- [ ] Create migration files
- [ ] Implement Prisma models
- [ ] Add unique constraints (org domain, user email)
- [ ] Create indexes for `(organization_id)` queries
- [ ] Add soft delete columns (`deleted_at`)
- [ ] Test multi-tenant data isolation

#### Validation Queries
```sql
-- Verify org isolation
SELECT COUNT(*) FROM memberships WHERE organization_id = 1;
SELECT COUNT(*) FROM memberships WHERE organization_id = 2;
-- Should be different counts

-- Verify role assignment
SELECT u.email, r.name FROM users u
JOIN memberships m ON u.id = m.user_id
JOIN roles r ON m.role_id = r.id
WHERE m.organization_id = 1;
```

#### Dependencies for Next Phase
- âœ… All tables ready
- âœ… Org isolation pattern established
- âœ… User-Role mapping functional

---

### **Phase 2: Contact Management & Validation (Week 2)**
**Goal:** Support email list uploads and validation pipeline

#### Tables to Create
1. `contact_lists` - Uploaded lists metadata
2. `contacts` - Individual email entries
3. `validation_rules` - Email validation config
4. `validation_logs` - Audit trail for validations

#### Implementation Tasks
- [ ] Design ContactList with org_id FK
- [ ] Create Contact table with validation_status enum
- [ ] Add validation_details as JSONB column
- [ ] Create ValidationRule table with versioning
- [ ] Create ValidationLog for audit trail
- [ ] Add indexes for common filters:
  - `(organization_id, validation_status)`
  - `(contact_list_id, validation_status)`
- [ ] Add soft delete to Contact and ContactList
- [ ] Implement bulk insert optimization for CSV upload

#### Validation Queries
```sql
-- Contact count by validation status
SELECT validation_status, COUNT(*)
FROM contacts
WHERE organization_id = ? AND contact_list_id = ?
GROUP BY validation_status;

-- Validation audit trail
SELECT cr.rule_type, vl.result, COUNT(*)
FROM validation_logs vl
JOIN validation_rules cr ON vl.validation_rule_id = cr.id
WHERE vl.contact_id IN (...)
GROUP BY cr.rule_type, vl.result;
```

#### Performance Considerations
- Batch insert 1000+ contacts efficiently
- Index optimization for CSV parsing
- Avoid N+1 queries in validation loop

#### Dependencies for Next Phase
- âœ… Contact lists can be imported
- âœ… Validation status tracked
- âœ… Audit trail established

---

### **Phase 3: Campaign & Template System (Week 3)**
**Goal:** Create campaign infrastructure and landing page forms

#### Tables to Create
1. `email_templates` - Email HTML templates
2. `forms` - Landing page form definitions
3. `form_fields` - Dynamic form field metadata
4. `campaigns` - Campaign master records
5. `campaign_contact_assignments` - Contact-Campaign state tracking

#### Implementation Tasks
- [ ] Create EmailTemplate with versioning
- [ ] Create Form with JSONB form_fields definition
- [ ] Create FormField table for indexed filtering
- [ ] Create Campaign with status enum (draft, scheduled, active, completed)
- [ ] Create CampaignContactAssignment for state tracking
- [ ] Add foreign keys linking Campaign to Template and Form
- [ ] Add indexes:
  - `(organization_id, campaign_id, status)`
  - `(campaign_id, contact_id)` - unique constraint
- [ ] Add soft delete to all campaign-related tables
- [ ] Generate unique landing_page_url slug per campaign

#### Validation Queries
```sql
-- Campaign overview
SELECT c.id, c.name, COUNT(cca.id) as contact_count
FROM campaigns c
LEFT JOIN campaign_contact_assignments cca ON c.id = cca.campaign_id
WHERE c.organization_id = ? AND c.deleted_at IS NULL
GROUP BY c.id;

-- Form field structure
SELECT ff.field_key, ff.field_label, ff.field_type
FROM form_fields ff
WHERE ff.form_id = ?
ORDER BY ff.position;
```

#### Performance Considerations
- Landing page URL must be unique and indexed
- Form field queries should be fast (frequently accessed)
- CampaignContactAssignment must support bulk insert (1000+ contacts/campaign)

#### Dependencies for Next Phase
- âœ… Campaigns can be created
- âœ… Forms can be linked to campaigns
- âœ… Landing pages ready for event tracking

---

### **Phase 4: Event Tracking & Simulation (Week 4)**
**Goal:** Core analytics data layer - events and aggregations

#### Tables to Create
1. `events` - Individual events (APPEND-ONLY, high volume)
2. `event_aggregations` - Pre-computed daily summaries
3. `email_send_simulations` - Mock service configuration

#### Implementation Tasks
- [ ] Create Event table with:
  - Enum for event_type (SENT, OPEN, CLICK, BOUNCE, UNSUBSCRIBE, FORM_VIEW, FORM_SUBMIT)
  - Timestamp (when event occurred)
  - JSONB event_data (flexible event details)
- [ ] Add indexes for dashboard queries:
  - `(organization_id, campaign_id, event_type, timestamp DESC)`
  - `(organization_id, timestamp DESC)` - for time-range queries
- [ ] Create EventAggregation table:
  - `(campaign_id, event_type, date)` - unique constraint
  - count, unique_contacts
- [ ] Create EmailSendSimulation for reproducible mock data
- [ ] Add soft delete to EmailSendSimulation (not Event - append only)
- [ ] Design nightly aggregation job logic

#### Validation Queries
```sql
-- Daily aggregation for campaign
SELECT date, event_type, COUNT(*) as count, COUNT(DISTINCT contact_id) as unique_contacts
FROM events
WHERE campaign_id = ? AND date >= ?
GROUP BY date, event_type;

-- Recent events for dashboard
SELECT event_type, COUNT(*)
FROM events
WHERE organization_id = ? AND timestamp >= NOW() - INTERVAL '7 days'
GROUP BY event_type;
```

#### Performance Considerations
- **HIGH PRIORITY:** Events table partitioning strategy
  - By organization_id for isolation
  - By date range for archival
- Batch insert events in groups (100-1000)
- Pre-computed aggregations are CRITICAL for dashboard speed
- Archive old events (>2 years) to cold storage

#### Dependencies for Next Phase
- âœ… Events can be recorded
- âœ… Dashboard can query aggregations
- âœ… Simulation service can generate test data

---

### **Phase 5: Leads, Compliance & Finalization (Week 5)**
**Goal:** Lead capture, GDPR compliance, and operational health

#### Tables to Create
1. `leads` - Generated from form submissions
2. `form_responses` - Detailed form submission data
3. `audit_logs` - Immutable action log
4. `gdpr_requests` - GDPR access/deletion requests
5. `data_deletions` - GDPR deletion history

#### Implementation Tasks
- [ ] Create Lead table with:
  - Enum status (new, qualified, disqualified, contacted, converted)
  - Soft delete for GDPR compliance
- [ ] Create FormResponse with JSONB response_data
- [ ] Add indexes:
  - `(organization_id, campaign_id, status)`
  - JSONB GIN indexes on response_data for filtering
- [ ] Create AuditLog (append-only):
  - Enum action type (create, update, delete, export, etc.)
  - JSONB changes for diff tracking
- [ ] Create GDPRRequest table with:
  - Enum request_type (export, deletion)
  - Enum status (pending, processing, completed, failed)
- [ ] Create DataDeletion for deletion audit trail
- [ ] Design GDPR export query logic
- [ ] Design GDPR anonymization rules

#### Validation Queries
```sql
-- Lead conversion funnel
SELECT status, COUNT(*)
FROM leads
WHERE organization_id = ? AND campaign_id = ?
GROUP BY status;

-- GDPR request history
SELECT request_type, status, COUNT(*)
FROM gdpr_requests
WHERE organization_id = ?
GROUP BY request_type, status;

-- Immutable audit trail
SELECT user_id, entity_type, action, COUNT(*)
FROM audit_logs
WHERE organization_id = ? AND created_at >= ?
GROUP BY user_id, entity_type, action;
```

#### GDPR Compliance Logic
- [ ] Export: Collect all user data â†’ JSON/CSV â†’ Download
- [ ] Anonymization: Replace PII with hashes/UUIDs
- [ ] Soft delete: Mark as deleted but preserve for audit
- [ ] IP address anonymization: After 90 days â†’ NULL

#### Performance Considerations
- Audit logs can grow large â†’ consider partitioning by date
- GDPR export queries can be slow â†’ optimize or async
- Soft deletes add query filter overhead â†’ consider separate archive table

#### Final Validation
- [ ] All tables have organization_id (except global tables)
- [ ] All sensit actions logged to audit_logs
- [ ] Soft delete pattern consistent
- [ ] Indexes cover common queries
- [ ] Foreign keys are correct
- [ ] Constraints prevent invalid states

---

## ðŸ”„ Aggregation & Maintenance Jobs

### **Nightly Aggregation Job** (Runs 2 AM UTC)
```
Purpose: Pre-compute daily metrics for dashboard performance

1. For each (campaign_id, event_type, date) combination:
   - COUNT(*) as total_events
   - COUNT(DISTINCT contact_id) as unique_contacts
   - Store in event_aggregations table

2. Mark aggregation as is_final = true after 24h
   - Prevents dashboard data changing unexpectedly

3. Cleanup:
   - Delete individual events older than retention period
   - Archive to cold storage if needed
```

### **Weekly Audit Cleanup** (Runs Sunday 3 AM UTC)
```
Purpose: Anonymize old sensitive data (GDPR compliance)

1. Find audit_logs older than 90 days
2. Find events with ip_address older than 90 days
3. Anonymize: ip_address = NULL, anonymize PII in JSONs
```

### **Monthly Archive** (Runs 1st day of month, 4 AM UTC)
```
Purpose: Move old data to cold storage, keep hot data fast

1. Identify events older than 2 years
2. Export to S3/cold storage
3. Delete from main database
4. Update retention records
```

---

## ðŸ“Š Testing Strategy Per Phase

### **Phase 1: Isolation Testing**
```
Test Case: User A in Org 1 cannot see Org 2 data
- User A logs in â†’ sees only Org 1 users
- User A tries to access Org 2 user â†’ 403 Forbidden
- Query for "SELECT * FROM contacts" includes WHERE org_id = 1
```

### **Phase 2: Validation Testing**
```
Test Case: Email validation pipeline works end-to-end
- Upload 1000 emails
- Run validation rules
- Verify results stored
- Query validation_status = 'valid' returns expected count
```

### **Phase 3: Campaign Testing**
```
Test Case: Campaign state is trackable
- Create campaign â†’ status = 'draft'
- Link contacts â†’ CampaignContactAssignment rows created
- Verify forms linked correctly
- Test landing_page_url uniqueness
```

### **Phase 4: Event Testing**
```
Test Case: Events recorded and aggregated correctly
- Insert 10,000 test events
- Run aggregation job
- Verify EventAggregation matches manual count
- Test dashboard query performance (should be <100ms)
```

### **Phase 5: GDPR Testing**
```
Test Case: GDPR export and deletion work correctly
- Create GDPR export request â†’ verify data returned
- Create GDPR deletion request â†’ verify soft delete
- Verify audit trail recorded
- Verify PII anonymized
```

---

## âš ï¸ Migration Considerations

### **If Migrating from Existing Schema**
1. Create new tables alongside old
2. Data sync process (ETL)
3. Cutover testing
4. Soft launch to subset of orgs
5. Monitor for data inconsistencies

### **If Starting Fresh**
1. Create all Phase 1-2 tables first
2. Test org isolation before building features
3. Add event tracking last (easier to backfill)

---

## ðŸ“‹ Checklist Before Phase Completion

### **Per Phase Checklist**
- [ ] All migrations created and tested
- [ ] Prisma models generated
- [ ] Indexes created and explained (performance verified)
- [ ] Soft delete columns added where applicable
- [ ] Foreign key constraints in place
- [ ] Unique constraints verified
- [ ] Test data inserted
- [ ] Query performance acceptable
- [ ] Documentation updated

### **Final Checklist (All Phases)**
- [ ] Multi-tenant isolation verified
- [ ] RBAC enforced in queries
- [ ] Event volume can scale to 100M+ rows
- [ ] Dashboard queries execute in <500ms
- [ ] GDPR compliance implemented
- [ ] Audit trail captures all changes
- [ ] Soft delete pattern consistent
- [ ] Aggregation jobs work correctly
- [ ] Archive/retention policies defined
- [ ] Backup/recovery procedures documented

---

**Implementation Ready:** âœ…
**Estimated Total Time:** 5 weeks (with parallelization and experience)
**Risk Level:** Low (clear phases, testable at each step)
